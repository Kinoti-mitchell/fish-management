import{s}from"./main-DyVZDjuq.js";async function g(){try{const{data:r,error:e}=await s.from("sorting_batches").select("batch_number").not("batch_number","is",null).order("batch_number",{ascending:!1}).limit(1).maybeSingle();if(e)return console.warn("Error fetching existing batch numbers:",e.message),e.message&&e.message.includes("relation")&&e.message.includes("does not exist")?(console.warn("sorting_batches table does not exist, using timestamp-based batch number"),`Batch${Date.now().toString().slice(-6)}`):`Batch${Date.now().toString().slice(-6)}`;let t=1;if(r?.batch_number){const n=r.batch_number.match(/^Batch(\d+)$/);n&&(t=parseInt(n[1],10)+1)}return`Batch${t.toString().padStart(4,"0")}`}catch(r){return console.error("Error generating batch number:",r),`Batch${Date.now().toString().slice(-6)}`}}async function c(){try{const{data:r,error:e}=await s.from("warehouse_entries").select("entry_code").not("entry_code","is",null).order("entry_code",{ascending:!1}).limit(1).maybeSingle();if(e)return console.warn("Error fetching existing entry codes:",e.message),`WE${Date.now().toString().slice(-6)}`;let t=1;if(r?.entry_code){const n=r.entry_code.match(/^WE(\d+)$/);n&&(t=parseInt(n[1],10)+1)}return`WE${t.toString().padStart(3,"0")}`}catch(r){return console.error("Error generating unique entry code:",r),`WE${Date.now().toString().slice(-6)}`}}async function d(r){try{const{data:e,error:t}=await s.from("warehouse_entries").select("entry_code").eq("id",r).single();if(t)return console.warn("Error fetching entry code:",t.message),await c();if(e?.entry_code)return e.entry_code;const o=await c(),{error:n}=await s.from("warehouse_entries").update({entry_code:o}).eq("id",r);return n&&console.warn("Error updating entry code:",n.message),o}catch(e){return console.error("Error getting/generating entry code:",e),await c()}}async function a(){try{const{data:r,error:e}=await s.from("processing_records").select("processing_code").not("processing_code","is",null).order("processing_code",{ascending:!1}).limit(1).maybeSingle();if(e)return console.warn("Error fetching existing processing codes:",e.message),`PR${Date.now().toString().slice(-6)}`;let t=1;if(r?.processing_code){const n=r.processing_code.match(/^PR(\d+)$/);n&&(t=parseInt(n[1],10)+1)}return`PR${t.toString().padStart(3,"0")}`}catch(r){return console.error("Error generating unique processing code:",r),`PR${Date.now().toString().slice(-6)}`}}async function u(r){try{const{data:e,error:t}=await s.from("processing_records").select("processing_code").eq("id",r).single();if(t)return console.warn("Error fetching processing code:",t.message),await a();if(e?.processing_code)return e.processing_code;const o=await a(),{error:n}=await s.from("processing_records").update({processing_code:o}).eq("id",r);return n&&console.warn("Error updating processing code:",n.message),o}catch(e){return console.error("Error getting/generating processing code:",e),await a()}}export{g as generateUniqueBatchNumber,c as generateUniqueEntryCode,a as generateUniqueProcessingCode,d as getOrGenerateEntryCode,u as getOrGenerateProcessingCode};
